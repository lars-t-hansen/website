<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <title>Roadmap - WebAssembly</title>
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>


<body>
  <header class="page-section">
    <div class="container-narrow">
    <a class="site-logo" href="/"></a>
    <nav class="site-nav">
      <a class="site-nav-item btn" href="/">Overview</a>
      <a class="site-nav-item btn" href="/getting-started/developers-guide/">Getting Started</a>
      <a class="site-nav-item btn" href="/specs">Specs</a>
      <a class="site-nav-item btn" href="/roadmap/">Future features</a>
      <a class="site-nav-item btn" href="/community/resources/">Community</a>
      <a class="site-nav-item btn" href="/docs/faq/">FAQ</a>
    </nav>
    </div>
  </header>
  <section class="banner-update">
    <div class="container-narrow">
      <div class="banner-update-icon"></div>
      <span class="banner-update-date"></span>
      <span>WebAssembly 1.0 has shipped in 4 major browser engines.
        &nbsp;<img width="48px" src="/images/firefox.svg"/>
        &nbsp;<img width="48px" src="/images/chrome.svg"/>
        &nbsp;<img width="48px" srcset="/images/safari_48x48.png, /images/safari_96x96.png 2x, /images/safari_144x144.png 3x" src="/images/safari_48x48.png"/>
        &nbsp;<img width="48px" src="/images/edge.svg"/>
        &nbsp;&#8203;<a href="/roadmap/">Learn&nbsp;more</a></span>
    </div>
  </section>
  

<section>
  <div class="container">
  <h1 id="roadmap">Roadmap</h1>

<p>In November 2017, WebAssembly CG members representing four browsers, Chrome, Edge, Firefox, and WebKit, reached consensus that the design of the initial (MVP) WebAssembly API and binary format is complete to the extent that no further design work is possible without implementation experience and significant usage.</p>

<p>After the initial release, WebAssembly has been gaining new features through the <a href="https://github.com/WebAssembly/meetings/blob/master/process/phases.md">standardization process</a>. For the complete list of current proposals and their respective stages, check out the <a href="https://github.com/WebAssembly/proposals"><code class="highlighter-rouge">WebAssembly/proposals</code> repo</a>.</p>

<table id="feature-support">
  <caption>The table below aims to track implemented features in popular engines:</caption>
</table>
<script src="https://unpkg.com/wasm-feature-detect/dist/umd/index.js" crossorigin=""></script>

<script>
  (async () => {
    function partitionArray(arr, condition) {
      let matched = [];
      let unmatched = [];

      for (let item of arr) {
        if (condition(item)) {
          matched.push(item);
        } else {
          unmatched.push(item);
        }
      }

      return { matched, unmatched };
    }

    let { features, browsers } = await fetch('/features.json').then(res => res.json());
    let table = document.getElementById('feature-support');

    function h(name, props = {}, children = []) {
      let node = Object.assign(document.createElement(name), props);
      node.append(...children);
      return node;
    }

    let tBody = document.createElement('tbody');

    table.append(
      h('thead', {}, [
        h('tr', {}, [
          h('th'),
          h('th', {}, ['Your browser']),
          ...Object.entries(browsers).map(([name, { url, logo, version }]) =>
            h('th', {}, [
              h('a', { href: url }, [
                h('img', { src: logo, width: 32, height: 32 }),
                h('br'),
                name,
                h('sup', {}, [version]),
              ])
            ])
          )
        ])
      ]),
      tBody
    );

    let featureGroups = partitionArray(
      Object.entries(features).map(([name, feature]) => Object.assign(feature, { name })),
      feature => feature.phase >= 4
    );

    featureGroups = [
      { name: 'Standardized features', features: featureGroups.matched },
      { name: 'In-progress proposals', features: featureGroups.unmatched },
    ];

    const columnCount = 2 + Object.keys(browsers).length;

    for (let { name, features } of featureGroups) {
      tBody.append(
        h('tr', {}, [
          h('th', { colSpan: columnCount }, [name])
        ])
      );
      for (let { name, description, url, phase } of features) {
        let supportHTML = h('td');
        Promise.resolve()
          // Make sure to call `wasmFeatureDetect` inside a promise-chained
          // function so that we can still render table rows for features that
          // we don't have a detector yet.
          .then(() => wasmFeatureDetect[name]())
          .then(
            supported => (supported ? '✔️' : '❌'),
            err => '❌'
          )
          .then(textContent => {
            supportHTML.textContent = textContent;
          });
        tBody.append(
          h('tr', {}, [
            h('th', {}, [h('a', { href: url }, [description])]),
            supportHTML,
            ...Object.values(browsers).map(({ features }) => {
              let support = features[name];
              if (typeof support === 'string') {
                return h('td', { title: support, tabIndex: 0 }, ['⏳']);
              }
              return h('td', {}, [support ? '✔️' : support === null ? 'ⁿ/ₐ' : '❌']);
            })
          ])
        );
      }
    }
  })();
</script>

<p>To detect supported features at runtime from JavaScript, check out the <a href="https://github.com/GoogleChromeLabs/wasm-feature-detect"><code class="highlighter-rouge">wasm-feature-detect</code> library</a>, which powers the “Your browser” column above.</p>

  </div>
</section>
</body>
</html>

